[{"id":0,"href":"/sra-board-hardware-design/docs/lsa/","title":"Lsa","section":"Docs","content":" LSA - Line Sensor Array # Table of Contents # Overview Features Components of LSA Function of Components LED PhotoDiode IC LM324 Resistors Connections Working Principle Appplications Scope of Improvement Overview # The Line Sensor Array(LSA) is used to detect the white/black lined surface and it sends this data to the microcontroller ESP-32. Analyzing and processing the data received by the microcontroller ESP-32, the purpose of line following is achieved.\nPhysical PCB\nPCB Backside Features # Components used are readily available. Easy connections for output signals. Compact enough to fit into any project. Distinguished trace widths for Signal and Power Routes. Components of LSA # Component Description Quantity LED Emits light 4 PhotoDiode Absorbs light 4 IC LM324 Op.Amp. IC 1 Resistors Limit Current 8 JST Connector Connect PCB with other circuits 1 Function of Components # LED\nLSA consists of Four LED and PhotoDiode Pairs. The specific LED\u0026rsquo;s emit white light which is incident on the surface and some of it is absorbed by the surface. The voltage source For the LEDs to glow is VCC. PhotoDiode\nBased upon the reflectivity coefficient of the surface( generally less than 1), the remaining light reflected from the surface is captured by the Photodiodes. LEDs and complimentary photodiodes are used to efficiently detect the surface (white/black line) as the environment also contains unwanted light for the LSA sensor. The amount of light received is directly proportional to the current generated by it. More the light, more the current, more the reading. IC LM324\nThis is a Quad(4) OP.Amp. IC. Op.Amp i.e Operation Amplifiers amplify the current with constant volatge. Since the current reading from photo diodes is significantly small and difficult to compare, it needs to be amplified. The 4 amplified outputs serve as raw readings of LSA. Resistors\nNow to limit the current and thus to protect the LEDs, PhotoDiodes current limiting resistors are used. Connections # To connect LSA with the SRA Board, connect the JST connector in the following way:\nWorking Principle # LSA works on the principle of reflectivity of light for different types of surfaces. Black Surface -\u0026gt; HIGH absorptivity -\u0026gt; LESS reflectivity White Surface -\u0026gt; LOW absorptivity -\u0026gt; HIGH reflectivity Demonstration Applications # Obstacle detection on a clear path. Line Following. Distinguish Colours on a path. Scope of Improvement # LSA sometimes provides slightly inaccurate readings due to external light and conditions due to non uniformity of the colour of the path. Therefore, LSA has low accuracy. Hence LSA should be kept close to the ground. As of now only white and black surfaces are being mapped. Given accurate sensors and proper mapping we can map LSA for any range of RGB colours. "},{"id":1,"href":"/sra-board-hardware-design/docs/mpu/","title":"Mpu","section":"Docs","content":" TABLE OF CONTENTS # TABLE OF CONTENTS MPU6050 Connection with SRA Board Inertial Measurement Unit Initialising MPU6050 Gyroscope Reading Gyroscope Data Accelerometer Reading Accelerometer Data Accelerometer Euler Angles Complementary Filter Digital Motion Processor Reading Register Data Connection with SRA Board # MPU6050 # The MPU6050 is a 6-axis/6-DOF Motion Tracking Device. It is a Micro Electro-Mechanical System (MEMS). MEMS is a technology defined as miniaturized mechanical and electro-mechanical elements (i.e., devices and structures) that are made using the techniques of microfabrication. Their dimensions can range from one micron to several millimeters.\nThe 6050 has both a 3-axis Accelerometer and 3-axis Gyroscope integrated on a single chip. It is a commonly used chip that combines a MEMS gyroscope and a MEMS accelerometer and uses a standard I2C bus for data transmission The system processor is an I2C master to the MPU6050 (default address is 0x68 but can be changed to 0x69) The MPU6050 can also act as an I2C master and directly accept inputs from an external compass This is 3.3V device and hence is safe to connect to ESP32 pins directly. To give you some context:\nA Gyroscope is a device that measures the rate of change of angular position, aka the rotational velocity, over time in all 3 axes.\nAn accelerometer is a tool that measures acceleration in its own instantaneous rest frame(e.g. an accelerometer at rest on the surface of the Earth will measure an acceleration due to Earth\u0026rsquo;s gravity, straight upwards of g ≈ 9.81 m/s2 and will measure zero acceleration when in freefall)\nWhen the 6050 is used, it returns 6 values; 3 from the accelerometer and the other 3 from the gyroscope. Inertial Measurement Unit # These are small devices indicating changing orientation in smartphones, video game remotes, quadcopters, etc. The IMU has both a gyroscope which measures angular rate and an accelerometer which measures linear acceleration, and/or compasses (magnetometers) The number of sensor inputs in an IMU are referred to as ‘DoF’ (Degrees of Freedom), so a chip with a 3-axis gyroscope and a 3-axis accelerometer would be a 6-DOF IMU. Contents # MPU6050 includes Digital Motion Processor (DMP), which has property to solve complex calculations. It also consists of a 16-bit Analog to Digital Converter(ADC) hardware. This enables it to record 3-dimension motion at the same time. It has I2C bus interface to communicate with various microcontrollers. The main feature is that the MPU6050 is less expensive and that it can easily combine with accelerometer and gyroscope. Pins # The MPU-6050 module has 8 pins,\nVCC: Power supply pin. Connect this pin to +5V DC supply.\nGND: Ground pin. Connect this pin to ground connection.\nSCL: Serial Clock pin. Connect this pin to the microcontroller\u0026rsquo;s SCL pin.\nSDA: Serial Data pin. Connect this pin to the microcontroller\u0026rsquo;s SDA pin.\nXDA: Auxiliary Serial Data pin. This pin is used to connect other I2C interface enabled sensors\u0026rsquo; SDA pin to MPU-6050.\nXCL: Auxiliary Serial Clock pin. This pin is used to connect other I2C interface enabled sensors\u0026rsquo; SCL pin to MPU-6050.\nAD0: I2C Slave Address LSB pin. This is 0th bit in 7-bit slave address of device. If connected to VCC, then read as logic one and slave address changes.\nINT: Interrupt digital output pin.\nWorking of the 6050 # Initialising MPU6050 # A sample wiring of the device to ESP32 looks as follows: When powered up, MPU6050 will start in SLEEP mode. To use it, we need to first disable this SLEEP mode To use the I2C protocol, we send the value 0 to register PWR_MGMT_1 (0x6b) The procedure to do so is as follows : Send a start sequence Send the I2C address (0x68) of the MPU6050 with the R/W bit high Send the internal register number you want to write to (0x6b : PWR_MGMT_1) Send the data byte (0x00) - This will power on the device Send the stop sequence The data byte 0x00 sets all the bits of register 107 to 0, thus disabling SLEEP mode and CYCLE mode, and powering on the MPU-6050\nThere are various terms related with the Pulse Width Modulation:-\nOff-Time :- Duration of time period when the signal is low. ON-Time :- Duration of time period when the signal is high. Duty cycle :- It is the percentage of the time period when the signal remains ON during the period of the pulse width modulation signal. Period :- It is the sum of off-time and on-time of pulse width modulation signal. Gyroscope # When the gyros are rotated about any of the sense axes, the Coriolis Effect causes a vibration that is detected by a MEM inside MPU6050.\nThe resulting signal is amplified, demodulated, and filtered to produce a voltage that is proportional to the angular rate.\nThis voltage is digitized using 16-bit ADC to sample each axis.\nThe full-scale range of output are +/- 250, +/- 500, +/- 1000, +/- 2000.\nIt measures the angular velocity along each axis in degree per second units.\nReading Gyroscope Data # The acceleration of the three axes, X,Y and Z, are stored in 3 pairs of registers on the MPU6050 Each register on the MPU6050 is an 8-bit register In each of these pairs, one register stores the MSB (most significant bit) and the other stores the LSB (least significant bit) These 6 registers are burst-read and the 8-bit MSB and LSB bytes for each axis are combined to give a single 16-bit float The gyroscope has a sensitivity factor of about 131, i.e. 1 degree of rotation gives a reading of 131 units Therefore, the degrees of rotation are obtained by dividing the raw readings by 131 Euler angles are calculated by integrating raw readings of each axis over time Accelerometer # The MPU6050 uses a MEMS accelerometer, which consists of stationary and movable electrodes acting as capacitor plates Acceleration along the axes deflects the movable mass. It produces change in g-forces on the moving device, which causes displacement of the movable capacitor plates. This displacement of moving plate (mass) unbalances the differential capacitor, which causes a change in the capacitance, which is then detected internally by change in voltage. This in turn results in sensor output. Output amplitude is proportional to acceleration. 16-bit ADC is used to get digitized output. The full-scale range of acceleration are +/- 2g, +/- 4g, +/- 8g, +/- 16g. It is measured in g (gravity force) unit; for example when the device is placed on a flat surface, it will measure 0g on X and Y axes and +1g on Z axis. Reading Accelerometer Data # The acceleration of the three axes, X,Y and Z, are stored in 3 pairs of registers on the MPU6050 Each register on the MPU6050 is an 8-bit register In each of these pairs, one register stores the MSB (most significant bit) and the other stores the LSB (least significant bit) These 6 registers are burst-read and the 8-bit MSB and LSB bytes for each axis are combined to give a single 16-bit float Accelerometer Euler Angles # The roll and pitch angles are calculated from the accelerometer using the formula below : Complementary Filter # Since gyroscopic drift accumulates over time, it is necessary to reset the rate readings from the gyroscope at frequent intervals, so the drift can be minimised To do this, we combine both the gyroscope and accelerometer readings in a weighted average The value of alpha is determined experimentally Formula: Digital Motion Processor (DMP) # Since the 6050 has multiple sensors, the input from these sensors can be fed into various complex algorithms that take raw data and convert it into extremely useful values(like an Inertial Navigation System as used in drones). Note that gyroscope and accelerometer sensor data of MPU6050 module consists of 16-bit raw data in 2’s complement form.\nThese algorithms are known as Fusion algorithms since they take input from multiple sensor types. The only problem is that these algorithms are: hard to understand since they contain a lot of mathematics and tend to be complicated, and demanding in RAM because of the amount of calculations that they require. This means that these algorithms are barely able to run on a relatively simple controller. This is where the DMP comes in.\nThe MPU-6050 DMP is quite sophisticated. It supports 3D motion processing and gesture recognition algorithms. It even reports temperature, and if you connect an external magnetometer, the DMP can also give you heading information. It is a motion sensing device that solve the problem mentioned above by running fusion algorithms internally. Hence, the SRA Board will be able to receive clean and reliable \u0026ldquo;fused\u0026rdquo; motion information from the module, instead of noisy motion data. Reading Register Data # To read/receive data from a slave, the master has to first send a START condition addressing the MPU6050 Then the master must WRITE the requested register from which the data is to be read After this, instead of sending a STOP condition to stop the WRITE operation and then sending a consecutive START condition to start the READ operation, the I2C bus provides the repeated start functionality, wherein instead of sending a STOP-START condition, we send only a START condition and read the specified number of bytes from the register. The procedure to do so is as follows : Send a start sequence Send the I2C address (0x68) of the MPU6050 with the R/W bit low - This writes to the device Send the Internal register address you want to read from Send a start sequence again (repeated start) Send the I2C address of the device with the R/W bit high - This reads from the device Read the number of the requested data bytes from the registers Send the stop sequence. All write and read operations (except the last read) are answered with a ACK if successful. "},{"id":2,"href":"/sra-board-hardware-design/docs/sra-board/","title":"Sra Board","section":"Docs","content":" SRA Development Board ESP32-based Development Board KiCAD · Gerber · Images · 3D Model SRA Board 2021-2022 # The SRA board is a development board based on ESP32 with on-board peripherals like programmable LEDs, switches, sensor ports for Line Sensor Array and MPU-6050, protection circuit for over-current and reverse voltage and motor drivers.\n![]/sra-board-hardware-design/documentation/assets/3d_sideview.png)\nTable of Contents # SRA Board 2021-2022 Table of Contents Board Images About the Project Getting Started with a Development Board Major Changes for 2022 Notable problems in the previous SRA Boards (2019) Notable problems in the current SRA Board 2022 3D Models Milestones Contributors Acknowledgements and Resources License Board Images # Frontside Backside About the Project # This development board is used for the Wall-E and MARIO workshops conducted by SRA. Designed using KiCAD. The schematic and board files are here. Resources for previous work. For more details of the SRA board 2020, checkout this link. The SRA board 2020 images can be found here. Older versions of the board and miscellaneous designs can be found here. Getting Started with a Development Board # In general, every development board has the following basic features:\nPower Supply Unit # Microcontrollers (MCUs) usually run on 3.3V or 5V logic supply voltage while input to a development board is normally 12V for motor and driving/controlling peripheral devices. So, in order to have a single input source, a power section which inter converts this 12V to standard levels like 5V \u0026amp; 3.3V for MCU and sensors is present.This is achieved using a step-down buck regulator. Buck Regulator IC LM2576-S-5 is used for stepping down the voltage from 12V to 5V DC. This 5V is further regulated to 3.3V using LDO IC AMS1117-3.3. The previous edition of the SRA board (2020) used a similar buck regulator setup. The older editions of the SRA board used the LM7805 linear voltage regulator, for stepping down from 12V to 5V; this powered the ESP32. Further, this 5V was converted to 3.3V using the LD33 linear voltage regulator, used by the sensor port. Motor Driver # Motors usually run on 12V and MCU output is generally 5V/3.3V. So, an external motor driver circuitry is required to control motors according to the MCU input. The current and previous editions of SRA board use the TB6612FNG Motor Driver, which is a MOS-based H-Bridge motor driver. The older editions of SRA Board used the L298N IC for motor-control, which is a BJT-based H-Bridge motor driver. Sensor Port # According to the external sensor types, usually development boards have onboard sensor ports where the sensors can be connected easily. LSA - Line Sensor Array and MPU- Motion Processing Unit have on-board connection ports. The current edition uses easily available and efficient JST XH connectors. Previous versions used bulky FRC connectors Protection against Reverse Voltage # The SRA Boards use diodes for reverse voltage protection in the power-line. 12V Motor line and power regulated line have been separated with SS34 and SS24 schottky diodes respectively. Protection against Over Current # Earlier, for the overcurrent protection of MCU and motor driver circuit, bulky glass fuses of 300mA and 3A were used respectively. After breakdown, they used to be replaced. In the recent versions of the board, these were replaced with compact, PTC Resettable Fuses. On 12V line - RXEF160 : 1.6A hold current; 3.2A trip current Fuse was used. On 5V line - RXEF160 : 0.5A hold current; 1A trip current Fuse was used. Programmable Switches and LEDs # Every development board should have some programmable switches and LEDs for testing, control and debugging purposes. The current editions has an array of 8 programmable LEDs and switches. The previous edition had a pair of programmable switches and programmable LEDs each. Power Switch # All versions have a power switch for the motor driver, using which power supply to the motor driver can be toggled. Similarly, there was a switch for the ESP32 MCU. Now that we covered basics of development boards, let us talk about the changes made in the new design.\nMajor Changes for 2022 # Feature SRA Board 2019 SRA Board 2020 SRA Board 2022 12V to 5V LM7805 Linear Regulator LM2596 Buck Convertor LM2576-S Buck Convertor 5V to 3.3V LD33 AMS1117-3.3 AMS1117-3.3 Reverse Voltage Protection Diodes P-MOSFET Diodes Motor Driver L298N TB6612FNG TB6612FNG No. of Motor Channels 2 4 4 No. of Switches 2 4 4 No. of LEDs 2 8 8 Over Current Protection Bulky Glass Fuses Bulky Glass Fuses PTC Resettable Fuses Sensor Port Connectors FRC (Fused Ribbon Cable) Connectors JST (Japan Solderless Terminal) Connectors JST Connectors Component Type and Board Size THT (Through Hole), Big THT (Through Hole), Big SMD(Surface Mount Device), Smaller 7805 (5V linear regulator) to LM2576/96 Buck Convertor # The greater efficiency, output current and reliability of LM2576/96 were the reasons for this change. The efficiency of LM2576 is up to 92% which is significantly better than 7805. The LM2576 can provide current up to 3A, so the MARIO workshop manipulator can now be run using onboard regulator. LD33 (3.3V) to AMS1117: # The older editions used the LD33 IC to step down from 5V to 3.3V; several discussions resulted in the shift to more compact, reliable AMS1117-3.3(SOT-23) linear voltage regulator. (AMS1117 is also used on-board on the ESP32-DevKitC V4 module) Reverse voltage protection: Diodes to P-MOSFET # Diodes in series to the power line are inefficient as compare to a P-MOSFET. Dut to the usage of high-rated motors, it was difficult to manage the diode size and the current rating. (As the current rating of diode increases, its size also increases.)So, the previous version uses the P-MOSFET instead of a diode, which is more efficient and can handle more current. In the current edition, SMD diodes are used, hence rating and size is no longer an issue. Component Type and Board Size: # In the previous and older editions, THT or PTH(Plated through hole) components were used, which take up a lot of space and their size increases with increasing rating. In the current edition, all the components were replaced by SMD components. This reduced cost, size of PCB and helped assembling complex circuitry in a small space and form factor. Previous edition PCB dimension - 81 x 112 mm Current edition PCB dimension - 81 x 92.68 mm (Nearly 81 x 20 mm area was shaved off) L298N to TB6612FNG # L298N is a BJT-based H-bridge motor driver but it is less efficient as compared to the new MOS-based TB6612FNG. The detailed comparison is shown below. As you can see the efficiency of TB6612FNG can reach up to 91-95% which is significantly higher than the 40-70% efficiency of L298N. The only drawback of TB6612FNG is the less continuous current which is equal to 1.2A. So, for higher current capacity motors, two TB6612FNG are given on the board, which can be used in parallel mode to double the current capacity to 2.4A. Motor Driver Modes # The new edition has 2x TB6612FNG motor drivers which allow a maximum of 4 motors to be controlled. This motor driver is characterized by its operation in two modes - Normal mode and Parallel mode:\nNormal Mode As discussed earlier, the new design has two motor drivers. Each TB6612FNG can control two motors. Therefore, using two motor driver one can control 4 motors using 8 GPIO\u0026rsquo;s of ESP32. E.g.: If pin 32 is HIGH(IN1 = HIHG) and pin 33 is low(IN2 = LOW) then motor 1 moves in the forward direction. So in normal mode, 4 motors can be connected to the board, with a per channel/motor current capacity of 1.2A. Parallel Mode The parallel mode is a special feature, used for high-rated motors, requiring more than the 1.2A current limit. In this mode, the channel\u0026rsquo;s directional pins and output pins are shorted; only one motor is connected to a motor driver i.e. two channels, giving a current capacity of 2.4A. Thus, two high rated motors can be controlled using ESP32. Note: The directional pin shorting is done by a manual DPDT switch. If the user turns on TB_A switch then the first motor driver goes into the parallel mode and its directional pins are shorted, where GPIO connections are IN1 = IN3 = 25 and IN2 = IN4 = 26. If TB_A switch is off, then the first motor driver goes into normal mode where IN1 = 32: IN2 = 33: IN3 = 25: IN4 = 26. This is all done automatically. Also for parallel mode, the J1, J2, J3 and J4 junctions need to be shorted. Moving back from the vintage Bar-graph LEDs to LED array and more switches # The older edition used a pair of programmable switches and LEDs each. Since the previous edition, the number of debuggable switches has been increased to 4. The previous edition used an LED voltage bar-graph array of 10 LEDs which was very bulky. In the current edition, 10 SMD LEDs arranged in an array out of which two are reserved for 5V and 3.3V voltage indication have been used. So there are 8 programmable LEDs on the board. These LEDs multiplexed with directional pins of the two motor drivers to save pins. Directional pins? \u0026raquo; Every motor driver channel has two directional pins IN1, IN2. If IN1 is high and IN2 is low then motors move in a clockwise direction and there are 4 channels on the board, so 4 * 2 = 8 directional pins are multiplexed with 8 programmable LEDs. With 8 LEDs in hand, debugging get easier. Some examples - According to the line sensor array (LSA) data, one can program 4 LEDs to turn on when the line sensor detects white and turn off for black- line following debugging. If a motor is moving in a forward direction, the dedicated LEDs will be indicating IN1 is high and IN2 is low - motor control debugging. Notable problems in the previous SRA Boards (2019) # The Simultaneous Power Supply Issue # ESP32 can be power using two ways - one via the USB port given on the ESP32 and two via providing a voltage on VIN pin. In the SRA Board 2019, if simultaneous power (on both the above sources) was provided to the ESP32 then it won\u0026rsquo;t work as there was no circuitry for handling such a condition. The following disclaimer from the official ESP32 documentation made it essential to design some external circuit to handle this condition and accordingly pass only one signal to the ESP32 board. The power supply must be provided using one and only one of the above options.Otherwise, the board and/or the power supply source can be damaged.\nSolution # The solution for this issue was Diode Auctioneering. There is an inbuilt BAT760 diode on the USB line on ESP32. If different voltages are applied at Vusb and Vin, then the voltage with bigger magnitude will be given to LD1117 (LDO on ESP32); often the voltage will be the same on Vin and Vusb i.e 5V. But, the usage of the SS14 (currently, 1N5417 in previous edition) diode on the Vin path, which has more Vf (forward voltage) than the BAT760, will create a voltage indifference and in a simultaneous power supply condition, USB will be selected as its voltage will be more than Vin. Notable problems in the current SRA Board 2022 # The High Frequency RF noise Issue # Currently 300rpm rated BO motors were ultilised for application. These are brushed DC motors functioning currently on 12v working on PWM concept.\nThese BO motors drain a lot of current during operation. 90 - 100 mA - during normal operation. But they drain about 600 - 700 mA current - during momentary or forced stalling. Momentary stalling happens by itself.\nFor self balancing operation - the MCU communicates with MPU6050 for the current orientational readings and accordingly gives commands to the motor driver and thus the motors.\nWhen this PWM goes over 50% duty cycle, the error in MPU readings become large and the motor rotate with full speed, thus not self-balancing the setup.\nThe following inspections were carried out os far so solve this issue.\nInspections # The static noise or low-frequecy noise generated by BO Motors was eliminated by soldering a 0.1uF ceramic capacitor across its terminals. Initially, the longer length of the I2C line route + cable from the MPU6050 to the ESP32 was suspected to be the main culprt. However, the MPU was checked for I2C packet drop, which when observed under the a DSO, seemed pretty fine. While reading the Motion data, both the SDA and SCLK lines go high. The dynamic high-frequency noise wasnt getting eliminated which is produced to the brush action of brushed DC motors. Finally adding ferrite beads across the motor terminals and using twisted cable pairs to connect it to the board lessened the RF noise to an extent. Although, the above solution only facililated in lessening the frequency of system going into error. Also, the duty cycle was forced to be under 50% for opltimal application. Possible Solutions # View this issue #14 for more details and advancements on the suggested solutions. The above error didnot occur when L298 motor driver was used with the same setup. Using N20 geared motors which draw relatively less current did not throw an error. Task is to figure out an economical alternative considering it to be a hardware issue. 3D Models # 3D preview of the SRA Board 2022\nThe complete 3D model (.step) file of SRA Board 2020 The 3D models of motor driver, LEDs, ESP32 etc.: 3d models of other components Milestones # Designing of the prototype board Modular testing of the circuit Testing of prototype board Final version Resolving high frequency noise by BO Motors ( TB6612FNG ) Contributors # Dhairya Shah: Designer Omkar Bhilare: Mentor VedantParanjape: Mentor Acknowledgements and Resources # Thanks to PCBPower Market for sponsoring the prototype and the final boards. Previous Edition: SRA Board 2020 KiCAD Tutorials README Template by roshanlam License # Distributed under the MIT License. "}]